package leetcode.everyday;


/**
 * 实现 pow(x, n) ，即计算 x 的 n 次幂函数。
 * <p>
 * 示例 1:
 * <p>
 * 输入: 2.00000, 10
 * 输出: 1024.00000
 * 示例 2:
 * <p>
 * 输入: 2.10000, 3
 * 输出: 9.26100
 * 示例 3:
 * <p>
 * 输入: 2.00000, -2
 * 输出: 0.25000
 * 解释: 2-2 = 1/22 = 1/4 = 0.25
 * 说明:
 * <p>
 * -100.0 < x < 100.0
 * n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。
 **/
public class _50_Pow {


    /**
     * 这题用到了数学推演法:
     * 假设: n的十进制可以使用二进制表示为:
     * n = 1*b1 + 2* b2 + 4* b3..+ 2^(f-1) * bf;
     * 那么x^n 就可以表示为
     * x^n = x^(1*b1 + 2* b2 + .+ 2^(f-1) * bf)
     * 我们展开其数学式就可以得知:
     * x^n = x^1*b1 * x^2* b2 * x^ 4* b3 *  .. x^ 2^(f-1) * bf)
     * 我们就可以把上述分为几个步骤:
     * 1. 我们需要知道x的1..f次幂是多少: x *= x; 循环相乘x就可以往上扩展
     * 2. 我们需要求出bf的值: 我们只要 b>> 1 就能知道当前的二进制值
     * <p>
     * <p>
     * 但是我们有快速幂的求解方法:
     * x^n => x^ n/2 * x^n/2 令 n/2 为整数，则要分两种情况： 奇偶 （设向下取整除法符号为 "//" ）：
     * <p>
     * {
     * (x^2) ^ n // 2 ( 为偶数）
     * x^n =>
     * x*(x^2) ^ n // 2 ( 为奇数）
     * }
     **/
    public double myPow(double x, int n) {
        // 如果x == 0，则无意义
        if (x == 0.0) {
            return 0.0d;
        }
        // 因为int32可能会溢出，需要使用64的long来进行存储
        long b = n;
        // 如果小于0需要转换一下求法
        if (b < 0) {
            x = 1 / x;
            b = -b;
        }
        // 进行循环求解
        double res = 1.0;
        while (b > 0) {
            // 根据快速幂，如果为奇数要* x;
            if ((b & 1) == 1) {
                res *= x;
            }
            // 进行x平方操作
            x *= x;
            // 删除最后一位
            b >>= 1;
        }
        return res;
    }
}
